{
  "hash": "3f0f932173ed2aced3cad8f06dc0a7c4",
  "result": {
    "markdown": "---\ntitle: \"Show all data in the background of your faceted ggplot\"\ndescription-meta: \"{{< meta website.description >}}\"\ndate: \"2023-01-22\"\nimage: teaser.png\naliases:\n  - 2020/background-data/index.html\n  - 2020/background-data\ncategories: [r, faceting, dataviz, trick]\n---\n\n\n\n\n***\n\nOne of the game-changing features of `ggplot2` was the ease with which one can explore the dimensions of the data using small multiples.[^1] There is a small trick that I was to share today -- put all the data in backgroung of every small multiple. This can considerably improve comparability of the data across the dimension which splits the dataset into the subsets for small multiples. Better to show right away what I mean and then explain in details. \n\nThere is a weekly dataviz challenge organized by Cole Knaflic. [One particular challenge][swd] stroke me as an ultimate case to showcase this background data trick. Here are the two plots:[^2] challenge one and my version.\n\n\n\n::: {layout-nrow=1}\n[![Image to improve](swd-challenge.png)](https://ikashnitsky.github.io/2023/backgroung-data/swd-challenge.png)  \n\n[![My version](improved.png)](https://ikashnitsky.github.io/2023/backgroung-data/improved.png)  \n:::\n\nIt is impossible to meaningfully compare and distinguish multiple spaghetti lines at once. Thus, my choice here was to use small multiples and look at them one by one. But we still want to compare the lines. For this, I added the pale background lines that show the spread of all data. Note that I also sorted the small multiples in the decreasing order and added the average line in yellow. \n\nBut the main trick here is adding all the data in the background. And with `ggplot2` it's super easy to do. All we need is to add a layer to the plot in which we modify the data removing the variable that was used for faceting. \n\nHere we use the nice feature of `ggplot2` -- the layers inherit whatever you specify in the main `ggplot()` call. In this case we are inheriting the `data` parameter and just remove the variable that is later used for faceting. \n\nConsider a pseudo-code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% \n    ggplot(PLOT_PARAMETERS)+\n    geom_WHATEVER(data = df %>% setect(-FACETING_VARIABLE))+\n    facet_wrap(~ FACETING_VARIABLE)\n```\n:::\n\n\n\nOnce we've done this, `gpplot2` no longer knows how to assign subsets of data to the corresponding small multiples; note that this only happens for the layer where we perform the trick and explicitly throw out the faceting variable. As the result, in each small multiple we end up with all the data. Put this layer in the backgroung, make it appropriately pale/transparent -- and that's it. I find this dataviz trick amazingly simple and powerful. \n\n***\n\n::: {.callout-tip}\n# You can replicate the full figure above using the `R` code from this [gist][gist]\n:::\n\n::: {.callout-note}\n# Faceting series\nThis post is the first one in the series of faceting tricks that I want to share. I'll add cross-links to the other posts here once they appear\n:::\n\n\n[^1]: At some point [`lattice`][lat] became pretty popular for the task, but then `ggplot2` entered the scene. \n[^2]: Images are clickable\n\n[cole]: https://twitter.com/storywithdata\n[swd]: https://twitter.com/storywithdata/status/1274019877779619841\n[lat]: https://cran.r-project.org/web/packages/lattice\n[gist]: https://gist.github.com/ikashnitsky/ee73b39e93f9d074d3362c7fb0d6c815\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}