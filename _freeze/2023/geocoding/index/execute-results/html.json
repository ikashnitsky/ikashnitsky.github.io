{
  "hash": "2df1c69ca7b693bc911876afcba6c247",
  "result": {
    "markdown": "---\ntitle: \"Geocode address text strings using `tidygeocoder`\"\ndescription-meta: \"{{< meta website.description >}}\"\ndate: \"2023-11-01\"\nimage: teaser.png\ncategories: [r, geocoding, rspatial, ggplot2]\n---\n\n\n\n\n***\n\nDeriving coordinates from a string of text that represents a physical location on Earth is a common geo data processing task. A usual use case would be an address question in a survey. There is a way to automate queries to a special GIS service so that it takes a text string as an input and returns the geographic coordinates. This used to be quite a challenging task since it required obtaining an API access to the GIS service like Google Maps. Things changed radically with the appearance of `tidygeocoder` that queries the free Open Street Map. \n\nIn this tiny example I'm using the birth places that students of my [2022 BSSD dataviz course][bssd] kindly contributed. In the class I asked students to fill a Google Form consisting of just two fields -- city and country of birth. The resulting small dataset is [here][data]\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(sf)\n\n# download the data\n# https://stackoverflow.com/a/28986107/4638884\nlibrary(gsheet)\n\nraw <- gsheet2tbl(\"https://docs.google.com/spreadsheets/d/1YlfLQc_aOOiTqaSGu5TI70OQy1ewTa_Ti0qAEOEcy58\")\n\n# clean a bit and join both fields in one text string \ndf <- raw |> \n    janitor::clean_names() |> \n    drop_na() |> \n    mutate(text_to_geocode = paste(city_settlement, country, sep = \", \"))\n```\n:::\n\n\nNow we are ready to unleash the power of `tidygeocoder`. The way the main unction in the package works is very similar to `mutate` -- you just specify which column of the dataset contains the text string to geocode, and it return the geographic coordinates.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidygeocoder)\n\ndf_geocoded <- df |> \n    geocode(text_to_geocode, method = \"osm\")\n```\n:::\n\n\nThe magic has already happened. The rest is just the routines to drop the points on the map. Yes, I am submitting this as my first 2023 entry to the [`#30DayMapChallenge`][30d] =)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# convert coordinates to an sf object\ndf_plot <- df_geocoded |> \n    drop_na() |> \n    st_as_sf(\n        coords = c(\"long\", \"lat\"),\n        crs = 4326\n    )\n```\n:::\n\n\nNext are several steps to plot countries of the worlds as the background map layer. Note that I'm using the trick of producing a separate lines layer for the country borders, there is a [separate post][borders] about this small dataviz trick.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get world map outline (you might need to install the package)\nworld_outline <- spData::world |> \n    st_as_sf()\n\n# let's use a fancy projection\nworld_outline_robinson <- world_outline |> \n    st_transform(crs = \"ESRI:54030\")\n\ncountry_borders <- world_outline_robinson |> \n    rmapshaper::ms_innerlines()\n```\n:::\n\n\nNow everything is ready to map!\n\n\n::: {.cell .column-screen-inset}\n\n```{.r .cell-code}\n# map!\nworld_outline_robinson |> \n    filter(!iso_a2 == \"AQ\") |> # get rid of Antarctica\n    ggplot()+\n    geom_sf(fill = \"#269999\", color = NA)+\n    geom_sf(data = country_borders, size = .25, color = \"#269999\" |> prismatic::clr_lighten())+\n    geom_sf(\n        data = df_plot, fill = \"#dafa26\", \n        color = \"#dafa26\" |> prismatic::clr_darken(),\n        size = 1.5, shape = 21\n    )+\n    coord_sf(datum = NA)+\n    theme_minimal(base_family = \"Atkinson Hyperlegible\")+\n    labs(\n        title = \"Birth places of the participants\",\n        subtitle = \"Barcelona Summer School of Demography dataviz course at CED, July 2022\",\n        caption = \"@ikashnitsky.phd\"\n    )+\n    theme(\n        text = element_text(color = \"#ccffff\"),\n        plot.background = element_rect(fill = \"#042222\", color = NA),\n        axis.text = element_blank(),\n        plot.title = element_text(face = 2, size = 18, color = \"#ccffff\")\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=100%}\n:::\n:::\n\n\n\nThat's it. Going from text to point on the map has never been easier.       \n\n\n***\n\n::: {.callout-note}\n# This post is one in the **dataviz course series**. Other posts:\n- [The easiest way to radically improve map aesthetics][borders]\n- [Show all data in the background of your faceted ggplot][bg]\n- [Dotplot â€“ the single most useful yet largely neglected dataviz type][dotplot]\n- [Save space in faceted plots][shrink]\n:::\n\n\n[bssd]: https://github.com/ikashnitsky/dataviz-bssd/releases/tag/v.3.0\n[borders]: https://ikashnitsky.phd/2023/map-borders/\n[bg]: https://ikashnitsky.phd/2020/background-data/\n[dotplot]: https://ikashnitsky.phd/2019/dotplot/\n[data]: https://docs.google.com/spreadsheets/d/1YlfLQc_aOOiTqaSGu5TI70OQy1ewTa_Ti0qAEOEcy58\n[30d]: https://30daymapchallenge.com\n[shrink]: https://ikashnitsky.phd/2023/shrink-space/\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}