{
  "hash": "0ebf83d8a6595417279c9cc7f1249b7e",
  "result": {
    "markdown": "---\ntitle: \"Map projections -- fix your maps in one line\"\ndescription-meta: \"{{< meta website.description >}}\"\ndate: \"2023-11-04\"\nimage: teaser.png\ncategories: [r, rspatial, ggplot2]\n---\n\n\n\n\n***\n\nDid you ever think why we (okay, I'm clearly biased, maybe just many of us, humans) love maps so much? Why do they often work so much better than other types of dataviz? I think[^1] what makes the maps work is the speed with which we can recognize familiar shapes, most often countries. That's why it's so annoying when these shapes get distorted -- it hinders the smoothness of reading the map and kills the pleasure of the process. I'm sure this is the main reason why [cartograms][cart] exist forever as a cool idea but are rarely actually used -- people love the concept of them but hate actually looking at them. I deeply believe that immediate shape recognition is the kill feature of maps as a type of dataviz.\n\n[^1]: And here I have to say that I'm not an expert in the area of visual perception or psychology of human processing of dataviz. I know this is a huge, thrilling area of research, I just never followed systemically. Strictly speaking, what I'm going to tell further is likely some digested version of what I've seen, read, and thought through over years of being into dataviz. \n\nGeographic projections are a huge field of research in itself. There are infinite ways to project the  spherical globe (geoid) to the surface. It's a classical challenge with no single correct solution. Specific choice depends on the features we want to preserve/represent most correctly — distances, angles, shapes, or areas. In my experience, for most of our daily basic dataviz needs the most important is the shape — it helps recognizing objects and thus navigating through maps smoothly.\n\nThere is a brilliant 6-min video explainer of maps projections, I heartily recommend:\n\n<iframe width=\"100%\" height=\"650\" src=\"https://www.youtube.com/embed/kIID5FDi2JQ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen>\n</iframe>\n\nBeware, the choice of appropriate map projection can be a rabbit hole as deep as choosing fonts or colors for your dataviz -- you are warned. In all practical terms, a good strategy is to check what are the canonical projections for the territories one plans to map – that would help not to repel the reader through instantaneous non-recognition of the shape. One good resource for the task is http://epsg.io.\n\nJust accept that the perfect projection does not exist -- there's no such thing as ~~free lunch~~ perfect projection. Map projections always excel or fail in specific contexts. Here is an example when a very non-standard geographic projection is just perfect for the data it is showing and the story it is telling.\n\n[![](natgeo.png){width=70%}][natgeo]\n\n\nHere is another [animated example][volc].\n\nEven the most famous and [often][m1] [ridiculed][m2] Mercator projection has its major advantages -- it preserves the angles and that's why it was perfect for the early age of navigation. It's also pretty safe at preserving coordinates and thus most often is used as the basic projection in which geodata is stored and distributed. And this is the reason why we see it in published maps so often. Honestly, I'm really allergic to the view of Europe in Mercator projection.\n\n[![](badeu.png){width=70%}][badeu]\n\nAnd it's just unbelievable how often these repulsing maps come across in academic papers. Especially when you know that it really takes one line of code to fix it. So let's see how it's done.\n\n***\n\nFor the illustration below I will produce maps of Europe in (A) Mercator and (B) Lambert Equal Area Azimuthal projections, as usual using the beautiful geodata stored in the `{eurostat}` package. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(eurostat)\n\n# the built-in dataset of EU boundaries\ngd <- eurostat_geodata_60_2016 %>% \n    janitor::clean_names() \n\n# filters out only NUTS-2 regions \ngd_n2 <- gd %>%\n    filter(levl_code == 2) \n\n# let's build the most basic map\ngd_n2 %>% \n    ggplot() +\n    geom_sf()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=100% height=100%}\n:::\n:::\n\n\n\nNote all the overseas territories of France, Spain, and Portugal. At the next step I will remove them to zoom in to the usual scope of mainland Europe. I will also [add borders between the countries as lines][bord].\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# remove overseas territories\ngd_n2_main <- gd_n2 %>% \n    filter(!id %in% c(paste0('ES', c(63, 64, 70)), paste('FRY', 1:5, sep = ''), 'PT20', 'PT30')) \n\n# the lines level with borders at country level\nbord <- gd %>%\n    filter(levl_code == 0) %>% \n    rmapshaper::ms_innerlines()\n```\n:::\n\n\n\nNow, back to reprojecting. There are two ways of changing the projections with {sf}: either apply `st_transform(crs = [EPSG code])` to change your the projection of the geodata object OR fix it directly at the plotting stage via `coord_sf(crs = [EPSG code])`. I think it's generally easier to reproject the data once and work with it (panel B). But for completeness I will also show the on-the-fly `coord_sf()` when plotting in Mercator projection (panel A). \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# transform the projection to the one suitable for Europe\ngd_n2_main_laea <- gd_n2_main %>% \n    st_transform(crs = 3035)\n\na <- gd_n2_main %>% \n    ggplot() +\n    geom_sf(fill = \"#F48FB1\", color = NA)+\n    geom_sf(data = bord, color = \"#C2185B\", size = .5)+\n    coord_sf(crs = 3857)\n\nb <- gd_n2_main_laea %>% \n    ggplot() +\n    geom_sf(fill = \"#DCE775\", color = NA)+\n    geom_sf(data = bord, color = \"#AFB42B\", size = .5)\n\nlibrary(patchwork)\n\na + b + plot_annotation(tag_levels = \"A\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=100% height=100%}\n:::\n:::\n\n \n \nThat's it. That's the whole one-line trick. Check out my other post based on my [dataviz course materials][dv].\n\n\n***\n\n::: {.callout-note}\n# This post is one in the **dataviz course series**. Other posts:\n- [The easiest way to radically improve map aesthetics][bord]\n- [Show all data in the background of your faceted ggplot][bg]\n- [Dotplot – the single most useful yet largely neglected dataviz type][dotplot]\n- [Save space in faceted plots][shrink]\n- [Geocode address text strings using `tidygeocoder`][gcode]\n:::\n\n\n[cart]: https://r-graph-gallery.com/cartogram.html\n[30d]: https://30daymapchallenge.com\n[volc]: https://twitter.com/ikashnitsky/status/1261186743585386496\n[m1]: https://twitter.com/ikashnitsky/status/1442512307502780422\n[m2]: https://twitter.com/ikashnitsky/status/1531395881559375872\n[natgeo]: https://ikashnitsky.phd/2023/map-proj/natgeo.png\n[badeu]: https://ikashnitsky.phd/2023/map-proj/badeu.png\n[dv]: https://github.com/ikashnitsky/dataviz-art-skill\n\n[bord]: https://ikashnitsky.phd/2023/map-borders/\n[bg]: https://ikashnitsky.phd/2020/background-data/\n[dotplot]: https://ikashnitsky.phd/2019/dotplot/\n[shrink]: https://ikashnitsky.phd/2023/shrink-space/\n[gcode]: https://ikashnitsky.phd/2023/geocoding/\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}